import os
import time
import json
from flask import Flask
from threading import Thread

import telebot
from telebot import types

from pymongo import MongoClient
import cloudinary
import cloudinary.uploader

# Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©
TOKEN = os.environ.get("TOKEN")
bot = telebot.TeleBot(TOKEN)
OWNER_ID = 7054294622  # Ø¹Ø¯Ù‘Ù„ Ø±Ù‚Ù…Ùƒ Ù‡Ù†Ø§

maintenance_mode = False
# Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª ÙˆØ§Ù„Ø«ÙˆØ§Ø¨Øª Ø§ÙƒØªØ¨:

waiting_for_delete = {}

@bot.message_handler(commands=['off'])
def enable_maintenance(message):
    if message.from_user.id == OWNER_ID:
        global maintenance_mode
        maintenance_mode = True
        bot.reply_to(message, "âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø©. Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¢Ù† ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø©.")
        # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù„ÙƒÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø£Ù† Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ø§Ù„ØµÙŠØ§Ù†Ø©
        users = get_all_approved_users()
        for user_id in users:
            try:
                bot.send_message(user_id, "â³ Ø§Ù†ØªØ¸Ø± Ø«ÙˆØ§Ù†Ù Ù†ØªØ­Ù‚Ù‚ Ø£Ù†Ùƒ Ø§Ø´ØªØ±ÙƒØª ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§ØªğŸ“‚ØŒ")
            except:
                pass

@bot.message_handler(commands=['on'])
def disable_maintenance(message):
    if message.from_user.id == OWNER_ID:
        global maintenance_mode
        maintenance_mode = False
        bot.reply_to(message, "âœ… ØªÙ… Ø¥ÙŠÙ‚Ø§Ù ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø©. Ø§Ù„Ø¨ÙˆØª Ø¹Ø§Ø¯ Ù„Ù„Ø¹Ù…Ù„.")
        # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù„ÙƒÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø£Ù† Ø§Ù„Ø¨ÙˆØª Ø¹Ø§Ø¯ Ù„Ù„Ø¹Ù…Ù„
        users = get_all_approved_users()
        for user_id in users:
            try:
                bot.send_message(user_id, "âœ… ØªÙ… Ø¥ÙŠÙ‚Ø§Ù ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø©ØŒ Ø§Ù„Ø¨ÙˆØª Ø¹Ø§Ø¯ Ù„Ù„Ø¹Ù…Ù„. ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª ÙˆØ§Ù„Ø§Ø´ØªØ±Ø§Ùƒ.")
            except:
                pass
# Ø«Ù… ÙŠØ¨Ø¯Ø£ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ (ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¨ÙˆØªØŒ Ø§Ù„Ø¯ÙˆØ§Ù„ØŒ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø§Øª ... Ø§Ù„Ø®)

CLOUD_NAME = os.environ.get("CLOUD_NAME")
API_KEY = os.environ.get("API_KEY")
API_SECRET = os.environ.get("API_SECRET")

MONGODB_URI = os.environ.get("MONGODB_URI")

# Ø¥Ø¹Ø¯Ø§Ø¯ Cloudinary
cloudinary.config(
    cloud_name=CLOUD_NAME,
    api_key=API_KEY,
    api_secret=API_SECRET,
)

# Ø¥Ø¹Ø¯Ø§Ø¯ MongoDB
client = MongoClient(MONGODB_URI)
db = client["telegram_bot_db"]

# Ù…Ø¬Ù…ÙˆØ¹Ø§Øª (Collections)
approved_v1_col = db["approved_v1"]
approved_v2_col = db["approved_v2"]
notified_users_col = db["notified_users"]

subscribe_links_v1 = [
    "https://t.me/+2L5KrXuCDUA5ZWIy",
    "https://t.me/+SPTrcs3tJqhlMDVi",
    "https://t.me/+W2KuzsUu_zcyODIy",
    "https://t.me/+CFA6qHiV0zw1NjRk",
]

subscribe_links_v2 = [
    "https://t.me/R2M199",
    "https://t.me/SNOKER_VIP",
]

pending_check = {}
owner_upload_mode = {}
waiting_for_broadcast = {}

def load_approved_users(collection):
    return set(doc["user_id"] for doc in collection.find())

def add_approved_user(collection, user_id):
    if not collection.find_one({"user_id": user_id}):
        collection.insert_one({"user_id": user_id})

def remove_approved_user(collection, user_id):
    collection.delete_one({"user_id": user_id})

def has_notified(user_id):
    return notified_users_col.find_one({"user_id": user_id}) is not None

def add_notified_user(user_id):
    if not has_notified(user_id):
        notified_users_col.insert_one({"user_id": user_id})

def main_keyboard():
    return types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True).add(
        types.KeyboardButton("ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª1"), types.KeyboardButton("ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª2")
    )

def owner_keyboard():
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    markup.row("ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª1", "ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª2")
    markup.row("Ø­Ø°Ù ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª1", "Ø­Ø°Ù ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª2")
    markup.row("Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø§Ø¹ÙŠØ© Ù…Ø¹ ØµÙˆØ±Ø©")
    return markup

def get_all_approved_users():
    return set(
        user["user_id"] for user in approved_v1_col.find()
    ).union(
        user["user_id"] for user in approved_v2_col.find()
    )

@bot.message_handler(func=lambda m: m.text == "Ø­Ø°Ù ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª1" and m.from_user.id == OWNER_ID)
def delete_videos_v1(message):
    user_id = message.from_user.id
    try:
        res = cloudinary.Search().expression("folder:videos_v1").max_results(20).execute()
        videos = res.get("resources", [])
        if not videos:
            bot.send_message(user_id, "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª ÙÙŠ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª1.", reply_markup=owner_keyboard())
            return

        text = "ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª1:\n"
        for i, vid in enumerate(videos, 1):
            text += f"{i}. {vid['public_id'].split('/')[-1]}\n"
        text += "\nØ£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø­Ø°ÙÙ‡."

        bot.send_message(user_id, text)
        waiting_for_delete[user_id] = {"category": "v1", "videos": videos}

    except Exception as e:
        bot.send_message(user_id, f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª: {str(e)}", reply_markup=owner_keyboard())

@bot.message_handler(func=lambda m: m.text == "Ø­Ø°Ù ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª2" and m.from_user.id == OWNER_ID)
def delete_videos_v2(message):
    user_id = message.from_user.id
    try:
        res = cloudinary.Search().expression("folder:videos_v2").max_results(20).execute()
        videos = res.get("resources", [])
        if not videos:
            bot.send_message(user_id, "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª ÙÙŠ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª2.", reply_markup=owner_keyboard())
            return

        text = "ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª2:\n"
        for i, vid in enumerate(videos, 1):
            text += f"{i}. {vid['public_id'].split('/')[-1]}\n"
        text += "\nØ£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø­Ø°ÙÙ‡."

        bot.send_message(user_id, text)
        waiting_for_delete[user_id] = {"category": "v2", "videos": videos}

    except Exception as e:
        bot.send_message(user_id, f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª: {str(e)}", reply_markup=owner_keyboard())

@bot.message_handler(func=lambda m: m.from_user.id == OWNER_ID and waiting_for_delete.get(m.from_user.id))
def handle_delete_choice(message):
    user_id = message.from_user.id
    data = waiting_for_delete.get(user_id)
    if not data:
        return

    try:
        choice = int(message.text)
        videos = data["videos"]
        category = data["category"]

        if 1 <= choice <= len(videos):
            video_to_delete = videos[choice - 1]
            public_id = video_to_delete["public_id"]

            cloudinary.uploader.destroy(public_id, resource_type="video")

            bot.send_message(user_id, f"âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø±Ù‚Ù… {choice} Ø¨Ù†Ø¬Ø§Ø­.", reply_markup=owner_keyboard())
            waiting_for_delete.pop(user_id)

        else:
            bot.send_message(user_id, "âŒ Ø§Ù„Ø±Ù‚Ù… ØºÙŠØ± ØµØ­ÙŠØ­ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")

    except ValueError:
        bot.send_message(user_id, "âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ØµØ§Ù„Ø­.")

@bot.message_handler(commands=['start'])
def start(message):
    user_id = message.from_user.id
    first_name = message.from_user.first_name or "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø³Ù…"
    username = f"@{message.from_user.username}" if message.from_user.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ø±Ù"

    if user_id == OWNER_ID:
        bot.send_message(user_id, "Ù…Ø±Ø­Ø¨Ø§ Ù…Ø§Ù„Ùƒ Ø§Ù„Ø¨ÙˆØª!", reply_markup=owner_keyboard())
        return

    if not has_notified(user_id):
        total_users = len(get_all_approved_users())
        new_user_msg = f"""ğŸ‘¾ ØªÙ… Ø¯Ø®ÙˆÙ„ Ø´Ø®Øµ Ø¬Ø¯ÙŠØ¯ Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
-----------------------
â€¢ Ø§Ù„Ø§Ø³Ù… : {first_name}
â€¢ Ø§Ù„Ù…Ø¹Ø±Ù : {username}
â€¢ Ø§Ù„Ø§ÙŠØ¯ÙŠ : {user_id}
-----------------------
â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„ÙƒÙ„ÙŠ: {total_users}
"""
        bot.send_message(OWNER_ID, new_user_msg)
        add_notified_user(user_id)

    bot.send_message(user_id, "! Ø§Ø®ØªØ± Ø§Ù„ÙÙŠØ¯ÙˆÙ‡Ø§Øª Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±ğŸª©:", reply_markup=main_keyboard())

@bot.message_handler(func=lambda m: m.text == "ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª1")
def handle_v1(message):
    user_id = message.from_user.id

    if user_id in load_approved_users(approved_v1_col):
        send_videos(user_id, "v1")
    else:
        # âœ… Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨ÙŠØ© ÙÙ‚Ø· Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…Ø´ØªØ±ÙƒÙ‹Ø§ Ø¨Ø¹Ø¯
        bot.send_message(user_id, "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù‚Ø³Ù… ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª 1!\nÙ„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ØŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:")

        # Ù†ÙƒÙ…Ù„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù…Ù† Ø­ÙŠØ« ØªÙˆÙ‚Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        data = pending_check.get(user_id)
        if data and data["category"] == "v1":
            send_required_links(user_id, "v1")
        else:
            pending_check[user_id] = {"category": "v1", "step": 0}
            send_required_links(user_id, "v1")
            
@bot.message_handler(func=lambda m: m.text == "ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª2")
def handle_v2(message):
    user_id = message.from_user.id

    if maintenance_mode and user_id != OWNER_ID:
        bot.send_message(user_id, "â³ Ø§Ù†ØªØ¸Ø± Ø«ÙˆØ§Ù†Ù Ù†ØªØ­Ù‚Ù‚ Ø£Ù†Ùƒ Ø§Ø´ØªØ±ÙƒØª ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§ØªğŸ“‚ØŒ")
        return

    if user_id in load_approved_users(approved_v2_col):
        send_videos(user_id, "v2")
    else:
        bot.send_message(user_id, "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù‚Ø³Ù… ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª 2!\nÙ„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§ØªØŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:")

        data = pending_check.get(user_id)
        if data and data["category"] == "v2":
            send_required_links(user_id, "v2")
        else:
            pending_check[user_id] = {"category": "v2", "step": 0}
            send_required_links(user_id, "v2")

def send_required_links(chat_id, category):
    data = pending_check.get(chat_id, {"category": category, "step": 0})
    step = data["step"]
    links = subscribe_links_v1 if category == "v1" else subscribe_links_v2
    if step >= len(links):
        notify_owner_for_approval(chat_id, "Ù…Ø³ØªØ®Ø¯Ù…", category)
        bot.send_message(chat_id, "ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨Ùƒ Ù„Ù„Ù…ÙˆØ§ÙÙ‚Ø©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±.", reply_markup=main_keyboard())
        pending_check.pop(chat_id, None)
        return

    link = links[step]
    text = f"""ğŸš¸| Ø¹Ø°Ø±Ø§Ù‹ Ø¹Ø²ÙŠØ²ÙŠ .
ğŸ”°| Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§Ø© Ø§Ù„Ø¨ÙˆØª Ù„ØªØªÙ…ÙƒÙ† Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡

- {link}

â€¼ï¸| Ø§Ø´ØªØ±Ùƒ Ø«Ù… Ø§Ø±Ø³Ù„ /start"""

    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âœ… Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ø¶ØºØ· Ù‡Ù†Ø§ Ù„Ù„ØªØ­Ù‚Ù‚", callback_data=f"verify_{category}_{step}"))
    bot.send_message(chat_id, text, reply_markup=markup, disable_web_page_preview=True)

    pending_check[chat_id] = {"category": category, "step": step}

@bot.callback_query_handler(func=lambda call: call.data.startswith("verify_"))
def verify_subscription_callback(call):
    user_id = call.from_user.id
    _, category, step_str = call.data.split("_")
    step = int(step_str) + 1
    links = subscribe_links_v1 if category == "v1" else subscribe_links_v2

    if step < len(links):
        pending_check[user_id] = {"category": category, "step": step}
        send_required_links(user_id, category)
    else:
        bot.send_message(user_id, """â³ Ø§Ù†ØªØ¸Ø± Ø«ÙˆØ§Ù†Ù Ù†ØªØ­Ù‚Ù‚ Ø£Ù†Ùƒ Ø§Ø´ØªØ±ÙƒØª ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§ØªğŸ“‚ØŒ""")
        notify_owner_for_approval(user_id, call.from_user.first_name, category)
        pending_check.pop(user_id, None)

def notify_owner_for_approval(user_id, name, category):
    keyboard = types.InlineKeyboardMarkup()
    keyboard.row(
        types.InlineKeyboardButton("Ù‚Ø¨ÙˆÙ„", callback_data=f"approve_{category}_{user_id}"),
        types.InlineKeyboardButton("Ø±ÙØ¶", callback_data=f"reject_{category}_{user_id}")
    )
    bot.send_message(OWNER_ID, f"Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯ Ù…Ù† {name}\nØ§Ù„Ø¢ÙŠØ¯ÙŠ: {user_id}\nÙ„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª {category[-1]}", reply_markup=keyboard)

@bot.callback_query_handler(func=lambda call: call.data.startswith("approve_") or call.data.startswith("reject_"))
def handle_owner_response(call):
    parts = call.data.split("_")
    action, category, user_id = parts[0], parts[1], int(parts[2])

    if call.from_user.id != OWNER_ID:
        bot.answer_callback_query(call.id, "ØºÙŠØ± Ù…ØµØ±Ø­.")
        return

    if action == "approve":
        if category == "v1":
            add_approved_user(approved_v1_col, user_id)
        else:
            add_approved_user(approved_v2_col, user_id)
        bot.send_message(user_id, "âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„Ùƒ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©! ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª.")
        bot.edit_message_text("ØªÙ… Ø§Ù„Ù‚Ø¨ÙˆÙ„.", call.message.chat.id, call.message.message_id)
    else:
        bot.send_message(user_id, "âŒ Ù„Ù… ÙŠØªÙ… Ù‚Ø¨ÙˆÙ„Ùƒ. Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø¨ÙˆØª Ø«Ù… Ø£Ø±Ø³Ù„ /start Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
        bot.edit_message_text("ØªÙ… Ø§Ù„Ø±ÙØ¶.", call.message.chat.id, call.message.message_id)

@bot.message_handler(commands=['v1'])
def set_v1_mode(message):
    if message.from_user.id == OWNER_ID:
        owner_upload_mode[message.from_user.id] = "v1"
        bot.reply_to(message, "Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© ÙÙŠ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª1.")

@bot.message_handler(commands=['v2'])
def set_v2_mode(message):
    if message.from_user.id == OWNER_ID:
        owner_upload_mode[message.from_user.id] = "v2"
        bot.reply_to(message, "Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© ÙÙŠ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª2.")

@bot.message_handler(content_types=['video'])
def handle_video(message):
    user_id = message.from_user.id
    if user_id == OWNER_ID and user_id in owner_upload_mode:
        category = owner_upload_mode[user_id]

        # ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…Ù† ØªÙ„ØºØ±Ø§Ù…
        file_info = bot.get_file(message.video.file_id)
        downloaded_file = bot.download_file(file_info.file_path)

        # Ø­ÙØ¸ Ù…Ø¤Ù‚Øª
        tmp_filename = f"temp_video_{int(time.time())}.mp4"
        with open(tmp_filename, "wb") as f:
            f.write(downloaded_file)

        # Ø±ÙØ¹ Ø¥Ù„Ù‰ Cloudinary
        try:
            upload_res = cloudinary.uploader.upload_large(tmp_filename, resource_type="video", folder=f"videos_{category}")
            video_url = upload_res.get("secure_url")

            bot.reply_to(message, f"âœ… ØªÙ… Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø­Ø§Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­!\nØ±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ:\n{video_url}")
        except Exception as e:
            bot.reply_to(message, f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {str(e)}")
        finally:
            # Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø¤Ù‚Øª
            if os.path.exists(tmp_filename):
                os.remove(tmp_filename)

    else:
        bot.reply_to(message, "âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª.")

def send_videos(chat_id, category):
    # Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¹Ù† ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ù…Ù† Cloudinary Ø¨Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
    try:
        res = cloudinary.Search().expression(f"folder:videos_{category}").max_results(20).execute()
        resources = res.get("resources", [])
        if not resources:
            bot.send_message(chat_id, "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø­Ø§Ù„ÙŠØ§Ù‹.", reply_markup=main_keyboard())
            return

        for video in resources:
            url = video["secure_url"]
            bot.send_video(chat_id, url)
    except Exception as e:
        bot.send_message(chat_id, f"Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª: {str(e)}", reply_markup=main_keyboard())

@bot.message_handler(func=lambda m: m.text == "Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø§Ø¹ÙŠØ© Ù…Ø¹ ØµÙˆØ±Ø©" and m.from_user.id == OWNER_ID)
def ask_broadcast_photo(message):
    bot.send_message(message.chat.id, "Ø£Ø±Ø³Ù„ Ù„ÙŠ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ù…Ø¹ Ø§Ù„Ø±Ø³Ø§Ù„Ø©.")
    waiting_for_broadcast["photo"] = True

@bot.message_handler(content_types=['photo'])
def receive_broadcast_photo(message):
    if waiting_for_broadcast.get("photo") and message.from_user.id == OWNER_ID:
        waiting_for_broadcast["photo_file_id"] = message.photo[-1].file_id
        waiting_for_broadcast["photo"] = False
        waiting_for_broadcast["awaiting_text"] = True
        bot.send_message(message.chat.id, "Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ù„ÙŠ Ù†Øµ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ù…Ø¹ Ø§Ù„ØµÙˆØ±Ø©.")

@bot.message_handler(func=lambda m: waiting_for_broadcast.get("awaiting_text") and m.from_user.id == OWNER_ID)
def receive_broadcast_text(message):
    if waiting_for_broadcast.get("awaiting_text"):
        photo_id = waiting_for_broadcast.get("photo_file_id")
        text = message.text
        users = get_all_approved_users()
        sent_count = 0
        for user_id in users:
            try:
                bot.send_photo(user_id, photo_id, caption=text)
                sent_count += 1
            except Exception:
                pass
        bot.send_message(OWNER_ID, f"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ø¹ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ {sent_count} Ù…Ø³ØªØ®Ø¯Ù….")
        waiting_for_broadcast.clear()

# --- Flask Web Server Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¹Ù„Ù‰ Render + UptimeRobot ---
app = Flask('')

@app.route('/')
def home():
    return "Bot is running"

def run():
    app.run(host='0.0.0.0', port=3000)

def keep_alive():
    t = Thread(target=run)
    t.start()

keep_alive()
bot.infinity_polling()
